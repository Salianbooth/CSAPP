Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp

   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax//从%fs段寄存器所指向的TLS段的0x28字节偏移处读取数据，并将该数据移动到%rax寄存器中。
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)//40106a~401073为把fs段偏移0x28的一个数据储存到%rsp+0x18处，这是为了防止缓存区溢出。（与金丝雀值有关）
   0x0000000000401078 <+22>:    xor    %eax,%eax//自己与自己异或，清零

   0x000000000040107a <+24>:    callq  0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>//比较我们输入的字符串长度是否为6，否则爆炸

   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx  //第一轮循环时，%rbx中存放着输入的字符串的地址，此时%rax=0x0，因此%ecx就存放着字符串的第一个字符，每次循环%rax+1

   0x000000000040108f <+45>:    mov    %cl,(%rsp)  //%cl是%ecx的低八位
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx    //%edx是%rdx的低32位，40108b~401096目的为只取(%ecx)的最低四位，存放到%edx中

   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx//"maduiersnfotvbyl So you think you can stop the bomb with ctrl-c, do you?"
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1) //%dl是%edx的低8位，将上一句的得到的字符传入栈中保存，(%rax)同样作为栈的索引，第一个字符就储存在(%rsp+0x10)
                                                            //退出循环时，栈上从(%rsp+0x10)开始按顺序存储着6个索引到的字符
   0x00000000004010a4 <+66>:    add    $0x1,%rax            //%rax 每次循环后+1
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax            //直到=6时退出循环

   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>//40108b~4010ac为一个循环，%eax在跳转前已被清空

   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi //  "flyers" //1001, 1111, 1110, 0101, 0110, 0111
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>

   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>

   0x00000000004010d2 <+112>:   mov    $0x0,%eax //清空eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>//跳回41

   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   callq  0x400b30 <__stack_chk_fail@plt>

   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   retq   